"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var os = require("os");
var path = require("path");
var fs = require("fs");
function readPackageVersion() {
    var packageJsonPath = path.resolve(__dirname, "../../package.json");
    try {
        var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
        if (packageJson && typeof packageJson.version === "string") {
            return packageJson.version;
        }
    }
    catch (e) { }
    return "unknown";
}
/**
 * Zero dependencies: recursive mkdir
 */
function mkDirByPathSync(HOME_DIR, targetDir, _a) {
    var _b = (_a === void 0 ? {} : _a).isRelativeToScript, isRelativeToScript = _b === void 0 ? false : _b;
    var sep = path.sep;
    var initDir = path.isAbsolute(targetDir) ? sep : "";
    var baseDir = isRelativeToScript ? __dirname : ".";
    return targetDir.split(sep).reduce(function (parentDir, childDir) {
        var curDir = path.resolve(baseDir, parentDir, childDir);
        try {
            // Don't try to recreate homedir
            if (HOME_DIR.indexOf(curDir) === -1) {
                fs.mkdirSync(curDir);
            }
        }
        catch (err) {
            if (err.code === "EEXIST") {
                return curDir;
            }
            // To avoid `EISDIR` error on Mac and `EACCES`-->`ENOENT` and `EPERM` on Windows.
            if (err.code === "ENOENT") {
                throw new Error("EACCES: permission denied, mkdir \"" + parentDir + "\"");
            }
            var caughtErr = ["EACCES", "EPERM", "EISDIR"].indexOf(err.code) > -1;
            if (!caughtErr || caughtErr && curDir === path.resolve(targetDir)) {
                throw err; // Throw if it"s just the last created dir.
            }
        }
        return curDir;
    }, initDir);
}
var StatusLogger = (function () {
    function StatusLogger() {
        this._HOME_DIR = os.homedir ? os.homedir() : (process.env[(process.platform == "win32") ? "USERPROFILE" : "HOME"]);
        this._FILE_PATH = this._HOME_DIR + "/LogFiles/ApplicationInsights/status/";
        this._FILE_NAME = "status_" + os.hostname() + "_" + process.pid + ".json";
        this.FULL_PATH = this._FILE_PATH + this._FILE_NAME;
    }
    StatusLogger.prototype.isNodeVersionCompatible = function () {
        var majVer = process.versions.node.split(".")[0];
        return parseInt(majVer) >= 1;
    };
    StatusLogger.prototype.makeStatusDirs = function (filepath) {
        if (filepath === void 0) { filepath = this._FILE_PATH; }
        try {
            return mkDirByPathSync(this._HOME_DIR, filepath.replace(/\\/g, path.sep).replace(/\//g, path.sep));
        }
        catch (e) {
            console.error("Error creating Application Insights status folder", e);
        }
    };
    StatusLogger.prototype.writeFile = function (data, cb) {
        var _this = this;
        fs.open(this.FULL_PATH, "w", function (err, fid) {
            if (err)
                return;
            fs.writeFile(_this.FULL_PATH, JSON.stringify(data, null, 2), { encoding: "utf8" }, function (err) {
                if (err) {
                    console.error("Error writing Application Insights status file", err);
                }
                if (cb && typeof cb === "function") {
                    cb(err);
                }
            });
        });
    };
    StatusLogger.prototype.addCloseHandler = function () {
        var _this = this;
        process.on("exit", function () {
            try {
                fs.unlinkSync(_this.FULL_PATH);
            }
            catch (err) { }
        });
    };
    StatusLogger._APP_TYPE = "node.js";
    StatusLogger.DEFAULT_STATUS = {
        AgentInitializedSuccessfully: false,
        SDKPresent: false,
        Ikey: null,
        AppType: StatusLogger._APP_TYPE,
        SdkVersion: readPackageVersion(),
        MachineName: os.hostname(),
        PID: String(process.pid)
    };
    return StatusLogger;
}());
exports.StatusLogger = StatusLogger;
//# sourceMappingURL=StatusLogger.js.map